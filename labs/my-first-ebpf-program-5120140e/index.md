---
kind: tutorial

title: Your First eBPF Program (and All the Steps Before)

description: |
  In this first tutorial, youâ€™ll run a pre-coded eBPF program and see it in action without writing any code yourself. Weâ€™ll walk through the important parts of the program so you understand how eBPF hooks and runs in the kernel. The goal is to get familiar with the workflow and core concepts before you start writing your own eBPF programs.

playground:
  name: my-ebpf-playground-85868132

categories:
- programming
- linux

tagz:
- ebpf

createdAt: 2025-08-20
updatedAt: 2025-08-20

cover: __static__/cover.png


# Uncomment to embed (one or more) challenges.
# challenges:
#   challenge_name_1: {}
#   challenge_name_2: {}

# Uncomment to add (one or more) background tasks.
# tasks:
#   init_task_1:
#     init: true
#     run: ...
#   regular_task_1:
#     run: ...
---

When you start the tutorial, you will see a `Term 1` on the right side. The current working directory (`/opt/ebpf/bcc/libbpf-tools`) includes the source code for lots of observability tools from the [BCC project](https://github.com/iovisor/bcc). 

We're going to use `execsnoop` for this example because of its simplicity. `execsnoop` is an eBPF program that traces and prints new process executions (`exec()` system calls) in real time. Hence, it serves as an excellent first program to showcase a trivial eBPF use case.

In general, every eBPF application usually consists out of at least two parts:

- A user-space program (USP) that declares the kernel space program and attaches it to the relevant tracepoint/probe.
- A kernel-space program (KSP) is what gets triggered and runs inside the kernel once the tracepoint/probe is met. This is where the actual eBPF logic is implemented.

Since these two programs aren't able to directly communicate with each other (by design), they need a buffer to exchange data. In the case of eBPF that's implemented via [different kind of BPF maps](https://docs.kernel.org/bpf/maps.html).

Let's build the executable, using:

```bash
make execsnoop
```

To actually run the compiled `execsnoop` binary, the `CAP_BPF` [Linux capability](https://man7.org/linux/man-pages/man7/capabilities.7.html) is required. 

That's mandatory because our logic uses privileged BPF operations (e.g. loading the eBPF code into the kernel) and at the same time many Linux distributions anyway don't allow unprivileged eBPF. `CAP_BPF` is available since Linux kernel 5.8 and allows loading all types of BPF programs, create most map types, load BTF, iterate programs and maps. 

::remark-box
---
kind: info
---

ðŸ’¡ `CAP_BPF` was introduced to separate out BPF functionality from the overloaded `CAP_SYS_ADMIN` capability. TODO: link?
::

However, since in this demo environment we are running as root anyway, this is not a problem. Run execsnoop:

```bash
./execsnoop
```

`execsnoop` will now show output each time any process is executed. But since there is little going on in a small VM like ours, we will generate some events. On the left side on the top, switch to the second `Term 2` tab, and execute:

```bash
cat /etc/os-release
```

Switch back to the first `Term 1` tab and see the output: a process execution of `cat` command has been captured and logged.

If you leave execsnoop running, from time to time you might see output generated by other processes running on the VM.

TODO: make it a helloworld for different programming languages
